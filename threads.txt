import asyncio
import websockets
import json
import base64
import ffmpeg
import uuid
import threading

# List of audio URLs with metadata
AUDIO_URLS = [
    {
        "url": "https://s3.us-east-1.amazonaws.com/twilio-calls-recordings/recordings/ACab32b204986a87a022a07b5cf4c95e0f/REaf0c60c181e2f36b0be8a20c80056767",
        "callerid": "+1234567890",
        "duration": 300,
        "sid": "CA1234567890abcdef",
        "transcript": "Hello, this is a test call.",
        "sentiment": "positive"
    },
    {
        "url": "https://s3.us-east-1.amazonaws.com/twilio-calls-recordings/recordings/ACab32b204986a87a022a07b5cf4c95e0f/RE3c3626c64b2ef45e00eb9ebf04dcd529",
        "callerid": "+1987654321",
        "duration": 150,
        "sid": "CAabcdef1234567890",
        "transcript": "This is another test call.",
        "sentiment": "negative"
    },
]

async def send_messages(websocket, message_queue):
    """ Sends messages from the queue to the WebSocket client. """
    try:
        while True:
            message = await message_queue.get()
            if message is None:
                break
            await websocket.send(json.dumps(message))
    except websockets.exceptions.ConnectionClosed:
        print("[INFO] Client disconnected.")

def stream_audio_thread(audio, audio_id, message_queue):
    """ Streams an audio file as base64 chunks and puts messages in the queue. """
    try:
        audio_uuid = str(uuid.uuid4())
        audio_info = {
            "audio_id": audio_id,
            "audio_uuid": audio_uuid,
            "callerid": audio["callerid"],
            "duration": audio["duration"],
            "sid": audio["sid"],
        }

        print(f"[START] Streaming {audio['sid']} with UUID: {audio_uuid}")
        message_queue.put_nowait({"type": "start", "audio_info": audio_info})

        process = (
            ffmpeg.input(audio["url"])
            .output('pipe:', format='wav', acodec='pcm_s16le')
            .run_async(pipe_stdout=True, pipe_stderr=True, quiet=True)
        )

        flag_counter = 0
        chunk_counter = 0

        while True:
            chunk = process.stdout.read(4096)
            if not chunk:
                break

            encoded_chunk = base64.b64encode(chunk).decode('utf-8')
            message_queue.put_nowait({
                "type": "audio_chunk",
                "audio_info": audio_info,
                "audio_data": encoded_chunk
            })

            chunk_counter += 1
            if chunk_counter % 10 == 0:
                flag_counter += 1
                print(f"[FLAG] Audio {audio['sid']} Flag {flag_counter}")
                message_queue.put_nowait({
                    "type": "flag",
                    "audio_info": audio_info,
                    "flag_number": flag_counter
                })

        process.wait()
        print(f"[COMPLETE] Streaming {audio['sid']} completed.")

        message_queue.put_nowait({"type": "stream_complete", "audio_info": audio_info})

    except Exception as e:
        print(f"[ERROR] Streaming audio {audio['sid']}: {e}")
        message_queue.put_nowait({"type": "error", "audio_info": audio_info, "message": str(e)})

async def handle_connection(websocket):
    """ Handles WebSocket connections and starts multiple audio streams in threads. """
    message_queue = asyncio.Queue()

    # Start a task to send messages from the queue
    send_task = asyncio.create_task(send_messages(websocket, message_queue))

    try:
        await message_queue.put({
            "type": "audio_urls",
            "urls": [audio["url"] for audio in AUDIO_URLS]
        })

        threads = []
        for idx, audio in enumerate(AUDIO_URLS):
            thread = threading.Thread(target=stream_audio_thread, args=(audio, idx, message_queue))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()

    except websockets.exceptions.ConnectionClosed:
        print("[INFO] Client disconnected, stopping audio streaming.")

    finally:
        await message_queue.put(None)  # Signal send_messages to exit
        await send_task  # Ensure message sending task completes
        print("[INFO] WebSocket connection closed.")

async def main():
    """ Starts the WebSocket server. """
    print("Starting WebSocket server on ws://localhost:5000")
    async with websockets.serve(handle_connection, "localhost", 5000):
        await asyncio.Future()

if __name__ == "__main__":
    asyncio.run(main())



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Streaming</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .audio-container { 
      margin-top: 20px; 
      padding: 15px; 
      background-color: #f8f8f8; 
      border-radius: 5px;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>

  <h2>Audio Streaming</h2>
  
  <div id="audio-streams"></div> <!-- Container for audio streams -->

  <script>
    const ws = new WebSocket('ws://localhost:5000');

    ws.onopen = () => {
      console.log('Connected to WebSocket server');
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);

      if (message.type === 'audio_urls') {
        console.log("Received audio URLs:", message.urls);
        const audioStreamsContainer = document.getElementById('audio-streams');
        audioStreamsContainer.innerHTML = ''; // Clear previous content

        message.urls.forEach((url, index) => {
          // Ensure each audio block is unique
          const streamContainer = document.createElement('div');
          streamContainer.classList.add('audio-container');

          // Show audio file number
          const title = document.createElement('h4');
          title.innerText = `Audio ${index + 1}`;
          streamContainer.appendChild(title);

          // Create an audio player
          const audioPlayer = document.createElement('audio');
          audioPlayer.controls = true;
          audioPlayer.src = url; // Set audio URL
          audioPlayer.id = `audio-player-${index}`;

          // Add event listener to notify backend when play is clicked
          audioPlayer.addEventListener('play', () => {
            console.log(`User started playing Audio ${index + 1}`);
            ws.send(JSON.stringify({ type: "play_audio", audio_id: index }));
          });

          // Append to container
          streamContainer.appendChild(audioPlayer);
          audioStreamsContainer.appendChild(streamContainer);
        });
      }
    };

    ws.onerror = (error) => console.error('WebSocket error:', error);
    ws.onclose = () => console.log('Disconnected from WebSocket server');
  </script>

</body>
</html>
